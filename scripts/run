#!/usr/bin/env python
import argparse
import warnings
from pathlib import Path
from typing import Union

import gif
import jax
import jax.numpy as jnp
import moviepy as mp
from gymnasium import Env, make
from gymnasium.error import NameNotFound
from jax.lib import xla_bridge
from matplotlib._api.deprecation import MatplotlibDeprecationWarning
from tqdm import tqdm
from jax.profiler import trace

import gym_cellular_automata as gymca
from gym_cellular_automata.agents.jax_ppo import run_rollout_loop
from gym_cellular_automata.forest_fire.bulldozer.utils.render import (
    render,
    plot_grid_attribute,
)
from multiprocessing import Pool
from functools import partial
from collections import defaultdict
import matplotlib
import numpy as np

DEFAULT_UPDATES = 40
DEFAULT_MILISECOND_FRAME = 80

matplotlib.use("agg")


# Add at the beginning of the file, after imports
def get_default_device():
    """Get the default JAX device (GPU/TPU if available, else CPU)"""
    return xla_bridge.get_backend().platform


# Set default device platform
DEFAULT_PLATFORM = get_default_device()
print(f"Default platform: {DEFAULT_PLATFORM}")

# Configure JAX to use the default platform
jax.config.update("jax_platform_name", DEFAULT_PLATFORM)


@gif.frame
def process_single_frame(args, empty, tree, fire, title, pos_fires):
    """Helper function that applies the decorator inside the process"""
    grid = args["grid"]
    time_per_frame = args["time"]
    position = args["position"]
    wind_index = args["wind_index"]
    game_idx = args["game_index"]
    frame_idx = args["frame_index"]
    cell_count = args["cell_count"]
    pos_fire = pos_fires[game_idx]

    # return make_frame_local(env, grid, time_per_frame, position, pos_fire, wind_index)
    plot = render(
        empty,
        tree,
        fire,
        title,
        grid,
        time_per_frame,
        position,
        cell_count,
        pos_fire,
        wind_index,
    )
    # plt.close("all")
    return plot


@gif.frame
def make_frame(plot):
    return plot


def get_run(env: Env, save_gif: bool):

    warnings.filterwarnings("ignore", category=MatplotlibDeprecationWarning)

    # @gif.frame
    def run(obs, info):
        # if save_gif:
        #     env.render()
        action = env.action_space.sample()
        step_tuple = env.stateless_step(action, obs, info)
        step_tuple = env.conditional_reset(step_tuple)
        return step_tuple

    return run


def generate_frames(
    env: Env,
    name: Union[str, Path],
    each: int = 1,
    updates: int = 50,
    duration_between: int = 50,
    save_gif: bool = True,
    num_envs: int = 8,
    profile: bool = False,
    no_train: bool = False,
):
    def get_paths(key: str, i: int) -> str:
        paths = {}
        if isinstance(name, str):
            # Create main gifs directory
            base_folder = Path().cwd() / "gifs"
            base_folder.mkdir(exist_ok=True)

            # Create env-specific subfolder
            env_folder = base_folder / name
            env_folder.mkdir(exist_ok=True)
            for j in range(num_envs):
                index_folder = base_folder / env_folder / f"{name}_{j}"
                index_folder.mkdir(exist_ok=True)

            # Set paths for all files
            paths = {
                "gif": base_folder
                / env_folder
                / f"{name}_{i}"
                / f"{name}_{key}_{i}.gif",
                "mp4": base_folder
                / env_folder
                / f"{name}_{i}"
                / f"{name}_{key}_{i}.mp4",
                "altitude": base_folder
                / env_folder
                / f"{name}_{i}"
                / f"{name}_{key}_{i}_altitude.png",
                "density": base_folder
                / env_folder
                / f"{name}_{i}"
                / f"{name}_{key}_{i}_density.png",
                "vegitation": base_folder
                / env_folder
                / f"{name}_{i}"
                / f"{name}_{key}_{i}_vegitation.png",
            }
        return paths[key]

    if no_train and name == "advanced_bulldozer":
        # Generate and save altitude plot
        # Generate and save altitude plots
        altitude_plots = env.altitude_render()
        for i in range(num_envs):
            altitude_plots[i].gcf().savefig(get_paths("altitude", i))
            altitude_plots[i].close()

        # Generate and save density plots
        density_plots = env.density_render()
        for i in range(num_envs):
            density_plots[i].gcf().savefig(get_paths("density", i))
            density_plots[i].close()

        # Generate and save vegetation plots
        vegetation_plots = env.vegitation_render()
        for i in range(num_envs):
            vegetation_plots[i].gcf().savefig(get_paths("vegitation", i))
            vegetation_plots[i].close()
    import time

    start_time = time.time()

    run = get_run(env, save_gif)
    frames_per_game = [[] for _ in range(num_envs)]
    next_obs, report = env.reset()
    next_info = {
        "TimeLimit.truncated": jnp.full(num_envs, False),
        "terminated": jnp.full(num_envs, False),
        "steps_elapsed": jnp.zeros(num_envs),
        "reward_accumulated": jnp.zeros(num_envs),
        "reward": jnp.zeros(num_envs),
    }

    def run_env(next_local_obs, next_info):
        for frame_index in tqdm(range(updates), desc="Generating frames"):
            (
                next_local_obs,
                reward,
                next_done,
                truncated,
                next_info,
            ) = run(next_local_obs, next_info)
            for game_index in range(next_local_obs[0].shape[0]):
                frames_per_game[game_index].append(
                    {
                        "grid": next_local_obs[0][game_index],
                        "wind_index": next_local_obs[1]["per_env_context"][
                            "wind_index"
                        ][game_index],
                        "time": next_local_obs[1]["time"][game_index],
                        "position": next_local_obs[1]["position"][game_index],
                        "frame_index": frame_index,
                        "game_index": game_index,
                        "cell_count": env.count_cells(next_local_obs[0][game_index]),
                    }
                )
        return next_local_obs, next_info

    if no_train:
        if profile:
            with trace(
                "./profile",
                create_perfetto_link=True,
                create_perfetto_trace=True,
            ):
                next_obs, next_info = run_env(next_obs, next_info)
        else:
            next_obs, next_info = run_env(next_obs, next_info)

        process_func = partial(
            process_single_frame,
            empty=env._empty,
            tree=env._tree,
            fire=env._fire,
            title=env.spec.id if env.spec is not None else env.title,
            pos_fires=env._pos_fire,
        )
        n_processes = 8

        # Process all frames in parallel
        num_games = next_obs[0].shape[0]
        games_dict = {i: {} for i in range(num_games)}  # Use dict for each game

        games = []
        for frames in frames_per_game:
            with Pool(processes=n_processes) as pool:
                games.append(
                    list(
                        tqdm(
                            pool.imap(process_func, frames),
                            total=len(frames),
                            desc=f"Processing frames",
                        )
                    )
                )
            # Unpack result on main thread

            # result_game_idx, result_frame_idx, frame, grid = result

            # num_fire_cells = (grid == env._fire).sum()
            # print(f"Number of fire cells: {num_fire_cells}")
            # print("Result game index", result_game_idx)
            # print("Result frame index", result_frame_idx)
            # # Run make_frame on main thread
            # processed_frame = make_frame(frame)
            # games_dict[result_game_idx][result_frame_idx] = {
            #     "frame": processed_frame,
            #     "grid": grid,
            # }

        # Convert dict to ordered list for each game

        # for game_idx in range(num_games):

        #     ordered_frames = []
        #     for idx in sorted(games_dict[game_idx].keys()):
        #         ordered_frames.append(games_dict[game_idx][idx]["frame"])
        #     games.append(ordered_frames)
        # import pdb

        # pdb.set_trace()

        for i in range(len(games)):
            # gif.save(games[i], str(get_paths("gif", i)), duration=duration_between)
            fps = 1000 / duration_between
            clip = mp.ImageSequenceClip([np.array(img) for img in games[i]], fps=fps)
            clip.write_videofile(
                get_paths("mp4", i), fps=30, threads=1, codec="libx264"
            )

    else:
        if profile:
            with trace(
                "./profile", create_perfetto_link=True, create_perfetto_trace=True
            ):
                grid_obs_list, agent_state = run_rollout_loop(
                    env, updates, num_envs=num_envs
                )
                grid_obs_list.block_until_ready()
        else:
            run_rollout_loop(env, updates, num_envs=num_envs)
    # for i in tqdm(range(updates), desc="Generating frames"):
    #     if i % each == 0:
    #         frames.append(make_frame())

    end_time = time.time()
    print(f"Generation completed in {end_time - start_time:.2f} seconds")


def generate_gif_envs(
    updates: int,
    duration_frame: int,
    save_gif: bool = True,
    num_envs: int = 8,
    profile=False,
    size=256,
    no_train=False,
):
    prototypes = ["helicopter", "bulldozer", "advanced_bulldozer"]

    proto_id = 2
    name = prototypes[proto_id]
    ProtoEnv = gymca.prototypes[proto_id]
    env = ProtoEnv(nrows=size, ncols=size, num_envs=num_envs)

    generate_frames(
        env,
        name,
        updates=updates,
        duration_between=duration_frame,
        save_gif=save_gif,
        num_envs=num_envs,
        profile=profile,
        no_train=no_train,
    )


# CLI args
parser = argparse.ArgumentParser()
parser.description = (
    "Generate gif files sample for each of the gym_cellular_automata library"
)


parser.add_argument(
    "--steps",
    "-s",
    type=int,
    default=DEFAULT_UPDATES,
    help=f"Steps to play on the environment. {DEFAULT_UPDATES}",
)

parser.add_argument(
    "--duration",
    "-d",
    type=float,
    default=DEFAULT_MILISECOND_FRAME,
    help=f"Time elapsed in miliseconds between each frame of the animation. "
    f"{DEFAULT_MILISECOND_FRAME}",
)

parser.add_argument(
    "--no-gif",
    action="store_true",
    help="Run without generating gif files",
)

parser.add_argument(
    "--num-envs",
    "-n",
    type=int,
    default=8,
)

parser.add_argument(
    "--profile",
    "-p",
    action="store_true",
    help="Run with profiling",
)

parser.add_argument(
    "--no-train",
    "-t",
    action="store_true",
    help="Run without training",
)

parser.add_argument(
    "--size",
    "-z",
    type=int,
    default=256,
)

if __name__ == "__main__":
    args = parser.parse_args()

    gif.options.matplotlib["dpi"] = 200
    generate_gif_envs(
        args.steps,
        args.duration,
        not args.no_gif,
        args.num_envs,
        args.profile,
        args.size,
        args.no_train,
    )
